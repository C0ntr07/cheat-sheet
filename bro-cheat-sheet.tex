\documentclass[10pt,landscape]{article}

\usepackage{alltt}
\usepackage{enumitem}
\usepackage[T1]{fontenc}
\usepackage[landscape,margin=13mm,footskip=1pt,includefoot]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{setspace}
%\usepackage[compact]{titlesec}
\usepackage{upquote}
\usepackage{xspace}

\graphicspath{{figs/}}

\pagestyle{empty}
\parindent=0pt

\setitemize{itemsep=1pt,topsep=0pt,parsep=1pt,leftmargin=10pt}

\hypersetup{
    colorlinks=true,        % false: boxed links; true: colored links
    linkcolor=red,          % color of internal links
    citecolor=cyan,         % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=blue           % color of external links
}

\def\todo#1{\textit{\textcolor{red}{TODO: #1}}}
\newcommand{\minisec}[1]{\textsc{#1}\\}

\def\first{\emph{(i)}~}
\def\second{\emph{(ii)}~}
\def\third{\emph{(iii)}~}
\def\fourth{\emph{(iv)}~}
\def\fifth{\emph{(v)}~}

\begin{document}

\begin{multicols*}{3}

{\Huge\scshape Bro Cheat Sheet}

\hfill\includegraphics[width=.4\linewidth]{bro-logo-small}
\vspace{-38pt}

{\scriptsize
\setstretch{1.5}
\begin{tabular}{l l}
Version: & \today\\
Website: & \url{http://www.bro-ids.org}\\
Email: & \texttt{\href{mailto:info@bro-ids.org}{info@bro-ids.org}}\\
Download: & \url{https://github.com/broids/cheat-sheet}
\end{tabular}
}

\section*{Startup}

\texttt{bro \textit{[options] [file \dots]}}\\
\texttt{\textit{file}} \dotfill Bro policy script or \texttt{stdin}\\
\texttt{-e \textit{code}} \dotfill Augment policies by given code\\
\texttt{-h} \dotfill Display command line options\\
\texttt{-i \textit{iface}} \dotfill Read from given interface\\
\texttt{-p \textit{pfx}} \dotfill Add given prefix to policy resolution\\
\texttt{-r \textit{file}} \dotfill Read from given PCAP file\\
\texttt{-w \textit{file}} \dotfill Write to given file in PCAP format\\
\texttt{-x \textit{file}} \dotfill Print contents of state file\\
\texttt{-C} \dotfill Ignore invalid checksum

\section*{Language}

Lowercase letters represent instance variables and uppercase letters represent
types. In general, \texttt{x} is an instance of type \texttt{T} and \texttt{y}
an instance of type \texttt{U}. Argument names and record fields begin begin
with \texttt{a}, \texttt{b},~\ldots, and \texttt{z} represents a default
instance variable which takes on the type of the right-hand side expression.
For notational convenience, \texttt{x} can often be replaced with an expression
of type \texttt{T}.
%Parenthesis after a type, e.g., \texttt{T()}, denote constructor invocation.

\subsection*{Variables}

Constant qualifier \dotfill \texttt{const}\\
Constant redefinition \dotfill \texttt{redef x \textit{op} \textit{expr}}\\
Scope qualifier \dotfill \texttt{local}, \texttt{global}\\
Declaration \dotfill \texttt{\textit{scope} x:~T}\\
Declaration \& Definition \dotfill \texttt{\textit{scope} z = \textit{expr}}

\subsection*{Declarations}

Type \dotfill \texttt{type~\textit{name}:~T}\\
Function \dotfill \verb|function f(a: T, ...): R|\\
Event \dotfill \verb|event e(a: T, ...)|

\subsection*{Modules}

Script import \dotfill \texttt{@load \textit{path}}\\
Set current namespace to \texttt{ns} \dotfill \texttt{module \textit{ns}}\\
Export global symbols \dotfill \verb|export { ... }|\\
Access \texttt{module} or \texttt{enum} namespace \dotfill \verb|T::a|

\subsection*{Statements}

Basic statement \dotfill
  \texttt{\textit{stmt};} or \texttt{\textit{expr};}\\
Code block \dotfill \texttt{\{ \textit{stmt}; ... \}}\\
Assignment \dotfill \texttt{z = \textit{expr}}\\
Function assignment \dotfill \texttt{z~=~function(...):~R~\{..\}}\\
Event queuing \dotfill \verb|event e(...)|\\
Event scheduling \dotfill \verb|schedule 10 secs { e(...) }|\\
Print expression to \texttt{stdout} \dotfill \texttt{print \textit{expr}}\\

\vspace{-10pt}
%\minisec{Control Flow}
\begin{multicols*}{3}
\textsc{Branching}
\begin{alltt}
if (\textit{expr})
    \{ \ldots \}
else if (\textit{expr})
    \{ \ldots \}
else
    \{ \ldots \}
\end{alltt}

\textsc{Iteration}
\begin{alltt}
for (i in x)
    \{ \ldots \}
\end{alltt}

\textsc{Asynchronous}
\begin{alltt}
when (\textit{expr}) \{ \ldots \}
when (local x = \textit{expr}) \{ \ldots \}
\end{alltt}
\vspace{-10pt}

\begin{alltt}
\textsc{Control}\vspace{5pt}
break
continue
next
return
\end{alltt}
\end{multicols*}

\subsection*{Expressions}

\minisec{Operators}
\verb|!| \dotfill Negation\\
\verb|$|, \verb|?$| \dotfill Dereference, record field existence\\
\verb|+|, \verb|-|, \verb|*|, \verb|/|, \verb|%| \dotfill Arithmetic\\
\verb|++|, \verb|--| \dotfill Post-increment, post-decrement\\
\verb|+=|, \verb|-=|, \verb|*=|, \verb|/=| \dotfill Arithmetic and assignment\\
\verb|==|, \verb|!=| \dotfill Equality, inequality\\
\verb|<|, \verb|<=|, \verb|>=|, \verb|>|
  \dotfill Less/greater than (or equal)\\
\verb|&&|, \verb#||# \dotfill Conjunction, disjunction\\
\verb|in|, \verb|!in| \dotfill Membership or pattern matching\\
\verb|[x]| \dotfill Index strings and containers\\
\verb#|x|# \dotfill Cardinality/size for strings and containers\\
\verb|f(...)| \dotfill Function call\\
\texttt{\textit{expr}$\;$?$\;$\textit{expr}$\;$:$\;$\textit{expr}}
  \dotfill Ternary if-then-else

\subsection*{Types}

\minisec{Basic}
\verb|addr| \dotfill IP address (\verb|127.0.0.1|)\\
\verb|bool| \dotfill Boolean flag (\verb|T|, \verb|F|)\\
\verb|count| \dotfill 64-bit unsigned integer (\verb|42|)\\
\verb|double| \dotfill Double-precision floating point (\verb|99.9|)\\
\verb|int| \dotfill 64-bit signed integer (\verb|-7|)\\
\verb|interval| \dotfill Time interval
  (\verb|8 sec|/\verb|min|/\verb|hr|/\verb|day[s]|)\\
\verb|pattern| \dotfill Regular expression (\verb|/^br[oO])$/|)\\
\verb|port| \dotfill Transport-layer port
  (\verb|22/tcp|, \verb|53/udp|)\\
\verb|string| \dotfill String of bytes (\verb|"foo"|)\\
\verb|subnet| \dotfill CIDR subnet mask (\verb|10.0.0.0/8|)\\
\verb|time| \dotfill Absolute epoch time (\verb|1320977325|)\\

\minisec{Enumerables}
Declaration \dotfill \verb|enum { FOO, BAR }|\\
Assignment \dotfill \texttt{\textit{scope}} \verb|x = FOO|\\

\minisec{Records}
Declaration \dotfill \verb|record { a: T, b: U, ... }|\\
Constructor \dotfill \verb|record($a=x, $b=y, ...)|\\
Assignment \dotfill \texttt{\textit{scope}} \verb|r = [$a=x, $b=y, ...]|\\
Access \dotfill \verb|z = r$a|\\
Field assignment \dotfill \verb|r$b = y|\\
Deletion \dotfill \verb|delete r$a|\\

\minisec{Sets}
Declaration \dotfill \verb|set[T]|\\
Constructor \dotfill \verb|set(x, ...)|\\
Assignment \dotfill \texttt{\textit{scope}} \verb|s = { x, ... }|\\
Access \dotfill \verb|z = s[x]|\\
Insertion \dotfill \verb|add s[x]|\\
Deletion \dotfill \verb|delete s[x]|\\

\minisec{Tables}
Declaration \dotfill \verb|table[T] of U|\\
Constructor \dotfill \verb|table([x] = y, ...)|\\
Assignment \dotfill \texttt{\textit{scope}} \verb|t = { [x] = y, ... }|\\
Access \dotfill \verb|z = t[x]|\\
Insertion \dotfill \verb|t[x] = y|\\
Deletion \dotfill \verb|delete t[x]|\\

\minisec{Vectors}
Declaration \dotfill \verb|vector of T|\\
Constructor \dotfill \verb|vector(x, ...)|\\
Assignment \dotfill \texttt{\textit{scope}} \verb|v = { x, ... }|\\
Access \dotfill \verb|z = v[0]|\\
Insertion \dotfill \verb|v[42] = x|
% FIXME: not yet supported in Bro, see #679.
%Deletion \dotfill \verb|delete v[3]|
\end{multicols*}

\begin{multicols*}{2}
\subsection*{Attributes}
Attributes occur at the end of type/event declarations and change their
behavior. The syntax is \verb|&key| or \verb|&key=val|, e.g.,
\verb|type T: set[count] &read_expire=5min| or
\verb|event foo() &priority=-3|.\\

\verb|&optional| \dotfill Allow record field to be missing\\
\verb|&default=x| \dotfill Use default value \texttt{x} for record fields and
  container elements\\
\verb|&redef| \dotfill Allow for redefinition of initial object value\\
% Users should use the logging framework instead.
%\verb|&rotate_interval=x| \dotfill Rotate file after time \verb|x|\\
%\verb|&rotate_size=x| \dotfill Rotate file after reaching size limit \verb|x|\\
%
% These do not seem to be worthwhile including
%\verb|&add_func=f| \dotfill Call \verb|f| after adding element to container\\
%\verb|&delete_func=f| \dotfill Call \verb|f| before deleting element from
%container \\
\verb|&expire_func=f| \dotfill Call \verb|f| right before container element
  expires\\
\verb|&read_expire=x| \dotfill Remove element after not reading it for time
  \verb|x|\\
\verb|&write_expire=x| \dotfill Remove element after not writing it for time
  \verb|x|\\
\verb|&create_expire=x| \dotfill Remove element after time \verb|x| from
  insertion\\
\verb|&persistent| \dotfill Write state to disk (per default on shutdown)\\
\verb|&synchronized| \dotfill Synchronize variable across nodes\\
% TODO: these are probably less relevant for users.
%\verb|&postprocessor| \dotfill \\
%\verb|&encrypt| \dotfill \\
%\verb|&match| \dotfill \\
\verb|&raw_output| \dotfill Do not escape non-ASCII characters when writing to
  a file\\
\verb|&mergeable| \dotfill Prefer set union to assignment for synchronized
  state\\
\verb|&priority=x| \dotfill Execution priority of event handler, higher values
first, default 0\\
  %$\mathtt{x} \in [-10,10]$ by convention\\
\verb|&group="x"| \dotfill Events in the same group can be jointly
  activated/deactivated\\
\verb|&log| \dotfill Write record field to log \\

\subsection*{Built-In Functions (BIFs)}
\linespread{0.9}

\subsubsection*{Core}

\begin{itemize}
  \item \verb|getenv(var: string): string|\\
    Returns the system environment variable identified by \texttt{var}.
  \item \verb|setenv(var: string, val: string): bool|\\
    Sets the system environment variable \texttt{var} to \texttt{val}.
  \item \verb|exit()|
    Shuts down the Bro process immediately.
  \item \verb|terminate(): bool|
    Gracefully shut down Bro by terminating outstanding processing. Returns
    true after successful termination and false when Bro is still in the
    process of shutting down.
  \item \verb|system(s: string): int|\\
    Invokes a command via the \texttt{system} function.
    Returns true if the return value of \texttt{system} was non-zero.
  \item \verb|system_env(s: string, env: any): int|\\
    Same as \verb|system|, but prepare the environment before invoking the
    command \texttt{s} with the set/table \texttt{env}.
  \item \verb|srand(seed: count)|\\
    Set the seed for subsequent \verb|rand| calls.
  \item \verb|rand(max: count): count|\\
    Returns a random value from the interval $[0, \mathtt{max})$.
  \item \verb|md5_hash(...): string|\\
    Computes the MD5 hash value of the provided list of arguments.
  \item \verb|md5_hash_init(index: any): bool|\\
    Initializes MD5 state for \texttt{index} to allow for computing hash values
    incrementally via the function \verb|md5_hash_update|. For example, when
    computing incremental MD5 values of transferred files in multiple
    concurrent HTTP connections, it is necessary to call
    \verb|md5_hash_init(c$id)| once before invoking
    \verb|md5_hash_update(c$id, some_more_data)| in the \verb|http_entity_data|
    event handler.
  \item \verb|function md5_hash_update(index: any, data: string): bool|\\
    Update the MD5 value associated with \texttt{index}. Note that it is
    necessary to call \verb|md5_hash_init(index)| once before calling this
    function to initialize the MD5 state.
  \item \verb|md5_hash_finish(index: any): string|\\
    Returns the final MD5 digest associated with the internal state identified
    by \texttt{index}.
  \item \verb|md5_hmac(...): string|\\
    Computes an HMAC-MD5 hash value of the provided list of arguments. The HMAC
    secret key is generated from available entropy when Bro starts up, or it
    can be specified for repeatability using the new \texttt{-K} flag.
% FIXME: move to an appropriate subsection.
  \item \verb|clear_table(v: any|\\
    Removes all elements from the set or table \texttt{v}.
\end{itemize}

\subsubsection*{Introspection}

\begin{itemize}
  \item \verb|current_time(): time|\\
    Returns the current wall-clock time.
  \item \verb|network_time(): time|\\
    Returns the timestamp of the last packet processed.
  \item \verb|reading_live_traffic(): bool|\\
    Checks whether Bro reads traffic from a network interface (as opposed to
    from a network trace).
  \item \verb|reading_traces(): bool|\\
    Checks whether Bro reads traffic from a trace file (as opposed to
    from a network interface).
  \item \verb|net_stats(): NetStats|\\
    Returns statistics about the number of packets
    \first received by Bro,
    \second dropped,
    and \third seen on the link (not always available).
  \item \verb|resource_usage(): bro_resources|\\
    Returns Bro process statistics, such as real/user/sys CPU time, memory
    usage, page faults, number of TCP/UDP/ICMP connections, timers, and events
    queued/dispatched.
  \item \verb|get_matcher_stats(): matcher_stats|\\
    Returns statistics about the regular expression engine, such as the number
    of distinct matchers, DFA states, DFA state transitions, memory usage of
    DFA states, cache hits/misses, and average number of NFA states across all
    matchers.
  \item \verb|get_gap_summary(): gap_info|\\
    Returns statistics about TCP gaps.
  \item \verb|same_object(o1: any, o2: any): bool|\\
    Checks whether \texttt{o1} and \texttt{o2} reference the same internal
    object.
  \item \verb|length(v: any): count|\\
    Returns the number of elements in the container \texttt{v}.
  \item \verb|val_size(v: any): count|\\
    Returns the number bytes that \texttt{v} occupies in memory.
  \item \verb|global_sizes(): table[string] of count|\\
    Returns a table containing the size of all global variables, where the
    index is the variable name and the value the variable size in bytes.
  \item \verb|global_ids(): table[string] of script_id|\\
    Returns a table with information about all global identifiers. The table
    value is a record containing the type name of the identifier, whether it is
    exported, a constant, an enum constant, redefinable, and its value (if it
    has one).
  \item \verb|record_fields(r: any): table[string] of record_field|\\
    Returns meta data about a record instance \texttt{r}, which includes the
    type name, whether the field is logged, its value (if it has one), and its
    default value (if specified).
\end{itemize}

\subsubsection*{Analyzer Behavior}

\begin{itemize}
  \item \verb|skip_further_processing(id: conn_id): bool|\\
    Stops processing packets belonging to the connection identified by
    \texttt{id}.
    Returns false if \texttt{id} does not point to an active connection and
    true otherwise.
    Note that this does not in itself imply that packets from this connection
    will not be recorded, which is controlled separately by
    \verb|set_record_packets|.
    \todo{Someone please verify this.}
  \item \verb|set_record_packets(id: conn_id, do_record: bool): bool|\\
    Controls whether packet contents belonging to the connection identified by
    \texttt{id} should be recorded.
    Note that this is independent of whether Bro processes the packets of this
    connection, which is controlled separately by
    \verb|skip_further_processing|.
    \todo{Someone please verify this.}
  \item \verb|set_contents_file(id: conn_id, direction: count, f: file): bool|\\
    Associates the file handle \texttt{f} with the connection identified by
    \texttt{id} for writing TCP byte stream contents. The argument
    \texttt{direction} controls what sides of the connection contents are
    recorded; it can take on four values:
    \verb|CONTENTS_NONE| to turn off recording of contents,
    \verb|CONTENTS_ORIG| to record originator contents,
    \verb|CONTENTS_RESP| to record responder contents,
    and \verb|CONTENTS_BOTH| to record both originator and responder contents.
    Returns false if \texttt{id} does not point to an active connection and
    true otherwise.
  \item \verb|get_contents_file(id: conn_id, direction: count): file|\\
    Returns the file handle associated with the connection identified by
    \texttt{id} and \texttt{direction}. If the connection exists but no
    contents file for \texttt{direction}, the function returns a handle to new
    file. If not active connection for \texttt{id} exists, it returns an error.
  \item \verb|skip_http_entity_data(c: connection, is_orig: bool)|\\
    Skips the data of the HTTP entity in the connection \texttt{c}. If
    \verb|is_orig| is true, the client data is skipped and the server data
    otherwise.
  \item \verb|skip_smtp_data(c: connection)|\\
    Skips SMTP data until the next email in \texttt{c}.
\end{itemize}

\subsubsection*{String Processing}

\begin{itemize}
  \item \verb|byte_len(s: string): count|\\
    Returns the number of characters (i.e., bytes) of \texttt{s}.
  \item \verb|sub_bytes(s: string, start: count, n: int): string|\\
    Get a substring of \texttt{s}, starting at position \texttt{start} and
    having length \texttt{n}.
  \item \verb|split(s: string, re: pattern): table[count] of string|\\
    Split \texttt{s} into an array using \texttt{re} to separate the elements.
    The returned table starts at index 1. Note that conceptually the return
    value is meant to be a vector and this might change in the future.
  \item \verb|split1(s: string, re: pattern): table[count] of string|\\
    Same as \texttt{split}, but \texttt{s} is only split once (if possible) at
    the earliest position and an array of two strings is returned. An array of
    one string is returned when \texttt{s} cannot be split.
  \item \verb|split_all(s: string, re: pattern): table[count] of string|\\
    Same as \texttt{split}, but also include the matching separators, e.g.,
    \verb|split_all("a-b--cd", /(\-)+/)| returns
    \verb|{"a", "-", "b", "--", "cd"}|. Odd-indexed elements do not match the
    pattern and even-indexed ones do.
  \item
\begin{verbatim}
split_n(s: string, re: pattern, incl_sep: bool,
        max_num_sep: count): table[count] of string
\end{verbatim}
    Similar to \verb|split1| and \verb|split_all|, but \verb|incl_sep|
    indicates whether to include matching separators and \verb|max_num_sep| the
    number of times to split \texttt{s}.
%  \item
%\begin{verbatim}
%function split_complete(s string, re: pattern,
%                        other: set[string], incl_sep: bool,
%                        max_num_sep: count): table[count] of string
%\end{verbatim}
%    Same as \verb|split_n|, except that the extra parameter \texttt{other} is
%    not used.
  \item \verb|sub(s: string, re: pattern, repl: string): string|\\
    Substitutes \texttt{repl} for the first occurrence of \texttt{re} in
    \texttt{s}.
  \item \verb|gsub(s: string, re: pattern, repl: string): string|\\
    Same as \texttt{sub} except that all occurrences of \texttt{re} are
    replaced.
  \item \verb|strcmp(s1: string, s2: string): int|
    Lexicographically compare \texttt{s1} and \texttt{s2}. Returns an integer
    greater than, equal to, or less than 0 according as \texttt{s1} is greater
    than, equal to, or less than \texttt{s2}.
  \item \verb|strstr(big: string, little: string): count|\\
    Locate the first occurrence of \texttt{little} in \texttt{big}.
    Returns 0 if \texttt{little} is not found in \texttt{big}.
  \item \verb|subst_string(s: string, from: string, to: string): string|\\
    Substitute each (non-overlapping) appearance of \texttt{from} in
    \texttt{s} to \texttt{to}, and return the resulting string.
  \item \verb|to_lower(s: string): string|\\
    Returns a copy of \texttt{s} with each letter converted to lower case.
  \item \verb|to_upper(s: string): string|\\
    Returns a copy of \texttt{s} with each letter converted to upper case.
  \item \verb|clean(s: string): string|\\
    Replace non-printable characters in \texttt{s} with escaped sequences,
    with the mappings
    \verb|0| $\rightarrow$ \verb|\0|,
    \verb|DEL| $\rightarrow$ \verb|^?|,
    values $\le 26$ $\rightarrow$ \verb|^[A-Z]|,
    and values not in $[32, 126]$~$\rightarrow$~\verb|%XX|.
  \item \verb|to_string_literal(s: string): string|\\
    Same as clean, but with different mappings:
    values not in $[32, 126]$~$\rightarrow$~\verb|%XX|,
    \verb|\|~$\rightarrow$~\verb|\\|,
    \verb|'|~$\rightarrow$~\verb|\'|,
    \verb|"|~$\rightarrow$~\verb|\"|.
  \item \verb|is_ascii(s: string): bool|\\
    Returns false if any byte value of \texttt{s} is greater than 127, and true
    otherwise.
  \item \verb|escape_string(s: string): string|\\
    Returns a printable version of \texttt{s}. Same as \texttt{clean} except
    that non-printable characters are removed.
  \item \verb|string_to_ascii_hex(s: string): string|\\
    Returns an ASCII hexadecimal representation of a string.
  \item \verb|str_split(s: string, idx: vector of count): vector of string|\\
    Splits \texttt{s} into substrings, taking all the indices in
    \texttt{idx} as cutting points; \texttt{idx} does not need to be sorted and
    out-of-bounds indices are ignored.
  \item \verb|strip(s: string): string|\\
    Strips whitespace at both ends of \texttt{s}.
  \item \verb|string_fill(len: int, source: string): string|\\
    Generates a string of size \texttt{len} and fills it with repetitions of
    \texttt{source}.
  \item \verb|str_shell_escape(source: string): string|\\
    Takes a string and escapes characters that would allow execution of
    commands at the shell level. Must be used before including strings in
    \verb|system| or similar calls.
  \item \verb|find_all(s: string, re: pattern) : set of string|\\
    Returns all occurrences of \texttt{re} in \texttt{s} (or an empty empty set
    if none).
  \item \verb|find_last(s: string, re: pattern) : string|\\
    Returns the last occurrence of \texttt{re} in \texttt{s}. If not found,
    returns an empty string.  Note that this function returns the match that
    starts at the largest index in the string, which is not necessarily the
    longest match.  For example, a pattern of \texttt{/.*/} will return the
    final character in the string.
  \item \verb|hexdump(data: string) : string|\\
    Returns a hex dump for \texttt{data}. The hex dump renders 16 bytes per
    line, with hex on the left and ASCII (where printable) on the right. Based
    on Netdude's hex editor code.
\end{itemize}

\subsubsection*{Math}

\begin{itemize}
  \item \verb|floor(x: double): double|\\
    Chops off any decimal digits of \texttt{x},
    i.e., computes $\lfloor\mathtt{x}\rfloor$.
  \item \verb|sqrt(x: double): double|\\
    Returns the square root of \texttt{x}, i.e., computes $\sqrt{\mathtt{x}}$.
  \item \verb|exp(x: double): double|\\
    Raises $e$ to the power of \texttt{x}, i.e., computes $e^\mathtt{x}$.
  \item \verb|ln(x: double): double|\\
    Returns the natural logarithm of \texttt{x},
    i.e., computes $\ln \mathtt{x}$.
  \item \verb|log10(x: double): double|\\
    Returns the common logarithm of \texttt{x},
    i.e., computes $\log_{10} \mathtt{x}$.
\end{itemize}

\subsubsection*{Conversion}

\begin{itemize}
  \item \verb|cat(...): string|\\
    Concatenates all given arguments into a single string.
  \item \verb|cat_sep(sep: string, default: string, ...): string|\\
    Similar to cat, but places \texttt{sep} between each given argument.
    If any of the variable arguments is an empty string it is replaced by
    \texttt{default} instead.
  \item \verb|fmt(...): string|\\
    Produces a formatted string. The first argument is the \emph{format string}
    and specifies how subsequent arguments are converted for output. It is
    composed of zero or more directives: ordinary characters (not \verb|%|),
    which are copied unchanged to the output, and conversion specifications,
    each of which fetches zero or more subsequent arguments. Conversion
    specifications begin with \verb|%| and the arguments must properly
    correspond to the specifier.
    After the \verb|%|, the following characters may appear in sequence:
    \begin{tabular}{l l}
      \verb|%| & Literal \verb|%|\\
      \verb|-| & Left-align field\\
      \verb|[0-9]+| & The field width (< 128)\\
      \verb|.| & Precision of floating point specifiers \verb|[efg]| (< 128)\\
      \verb|A| & Escape NUL bytes, i.e., replace \verb|0| with \verb|\0|\\
      \verb|[DTdxsefg]| &
        \begin{minipage}[t]{\linewidth}
          Format specifier\\
          \begin{tabular}{l p{.7\linewidth}}
            \texttt{[DT]} & ISO timestamp with microsecond precision\\
            \texttt{d} & Signed/Unsigned integer (using C-style
              \verb|%lld|/\verb|%llu| for \texttt{int}/\texttt{count})\\
            \texttt{x} & Unsigned hexadecimal (using C-style \verb|%llx|);
              addresses/ports are converted to host-byte order\\
            \texttt{s} & Escaped string\\
            \texttt{[efg]} & Double\\
          \end{tabular}
        \end{minipage}\\
    \end{tabular}
  \item \verb|type_name(t: any): string|\\
    Returns the type name of \texttt{t}.
  % TODO: maybe to low-level for the cheat sheet?
  \item \verb|record_type_to_vector(rt: string): vector of string|\\
    Converts the record type name \texttt{rt} into a vector of strings, where
    each element is the name of a record field. Nested records are flattened.
  \item \verb|to_int(s: string): int|\\
    Converts a \texttt{string} into a (signed) integer.
  \item \verb|int_to_count(n: int): count|\\
    Converts a positive integer into a \texttt{count} or returns 0 if
    \texttt{n < 0}.
  \item \verb|double_to_count(d: double): count|\\
    Converts a positive \texttt{double} into a \texttt{count} or returns 0 if
    \texttt{d < 0.0}.
  \item \verb|to_count(s: string): count|\\
    Converts a \texttt{string} into a \texttt{count}.
  \item \verb|interval_to_double(i: interval): double|\\
    Converts an \texttt{interval} time span into a \texttt{double}.
  \item \verb|double_to_interval(d: double): interval|\\
    Converts a \texttt{double} into an \texttt{interval}.
  \item \verb|time_to_double(t: time): double|\\
    Converts a \texttt{time} value into a \texttt{double}.
  \item \verb|double_to_time(d: double): time|\\
    Converts a \texttt{double} into a \texttt{time} value.
  \item \verb|double_to_time(d: double): time|\\
    Converts a \texttt{double} into a \texttt{time} value.
  \item \verb|port_to_count(p: port): count|\\
    Returns the port number of \texttt{p} as \texttt{count}.
  \item \verb|count_to_port(c: count, t: transport_proto): port|\\
    Creates a \texttt{port} with number \texttt{c} and transport protocol
    \texttt{t}.
  \item \verb|to_port(s: string): port|\\
    Converts a \texttt{string} into a \texttt{port}.
  \item \verb|addr_to_count(a: addr): count|\\
    Converts an IP address into a 32-bit unsigned integer.
  \item \verb|count_to_v4_addr(ip: count): addr|\\
    Converts an unsigned integer into an IP address.
  \item \verb|to_addr(ip: string): addr|\\
    Converts a \texttt{string} into an IP address.
  \item \verb|raw_bytes_to_v4_addr(b: string): addr|\\
    Converts a \texttt{string} of bytes into an IP address. It interprets the
    first 4 bytes of \texttt{b} as an IPv4 address in network order.
  \item \verb|ptr_name_to_addr(s: string): addr|\\
    Converts a reverse pointer name to an address, e.g.,
    \verb|1.0.168.192.in-addr.arpa| to \verb|192.168.0.1|.
  \item \verb|addr_to_ptr_name(a: addr): string|\\
    Converts an IP address to a reverse pointer name, e.g.,
    \verb|192.168.0.1| to \verb|1.0.168.192.in-addr.arpa|.
  \item \verb|parse_dotted_addr(s: string): addr|\\
    Converts a decimal dotted IP address in a string to an address type.
  \item \verb|parse_ftp_port(s: string): ftp_port|\\
    Converts a string representation of the FTP PORT command to an
    \verb|ftp_port|,
    e.g., \verb|"10,0,0,1,4,31"| to \verb|[h=10.0.0.1, p=1055/tcp, valid=T]|
  \item \verb|parse_eftp_port(s: string): ftp_port|\\
    Same as as \verb|parse_ftp_port|, but instead for EPRT
    (see~\href{http://tools.ietf.org/html/rfc2428}{RFC 2428}) whose format is
    \verb|EPRT<space><d><net-prt><d><net-addr><d><tcp-port><d>|, where
    \verb|<d>| is a delimiter in the ASCII range 33-126 (usually \verb#|#).
  \item \verb|parse_ftp_pasv(s: string): ftp_port|\\
    Converts the result of the FTP PASV command to an \verb|ftp_port|.
  \item \verb|parse_ftp_epsv(s: string): ftp_port|\\
    Same as \verb|parse_ftp_pasv|, but instead for the EPSV
    (see~\href{http://tools.ietf.org/html/rfc2428}{RFC 2428}) whose format is
    \verb|<text> (<d><d><d><tcp-port><d>)|, where \verb|<d>| is a delimiter in
    the ASCII range 33-126 (usually \verb#|#).
  \item \verb|fmt_ftp_port(a: addr, p: port): string|\\
    Formats the IP address \texttt{a} and TCP port \texttt{p} as an FTP
    PORT command, e.g., \verb|10.0.0.1| and \verb|1055/tcp| to
    \verb|"10,0,0,1,4,31"|.
  \item \verb|decode_netbios_name(name: string): string|\\
    Decode a \href{http://support.microsoft.com/kb/194203}{NetBIOS name}, e.g.,
    \verb|"FEEIEFCAEOEFFEECEJEPFDCAEOEBENEF"| to \verb|"THE NETBIOS NAME"|.
  \item \verb|decode_netbios_name_type(name: string): count|\\
    Converts the \href{http://support.microsoft.com/kb/163409}{NetBIOS name
    type} to the corresponding numeric value.
  \item \verb|bytestring_to_hexstr(bytestring: string): string|\\
    Converts a string of bytes into its hexadecimal representation, e.g.,
    \verb|"04"| to \verb|"3034"|.
  \item \verb|decode_base64(s: string): string|\\
    Decode the Base64-encoded string \verb|s|.
  \item \verb|decode_base64_custom(s: string, a: string): string|\\
    Decode the Base64-encoded string \verb|s| with alphabet \verb|a|.
\end{itemize}

\subsubsection*{Network Type Processing}

\begin{itemize}
  \item \verb|mask_addr(a: addr, top_bits_to_keep: count): subnet|\\
    Creates a subnet mask from \texttt{a} by specifying the number of top bits
    to keep. For example, \verb|mask_addr(10.5.1.3, 8)| would return
    \verb|10.0.0.0/8|.
  \item \verb|remask_addr(a1: addr, a2: addr, top_bits_from_a1: count): count|\\
    Takes some top bits (e.g., subnet address) from \texttt{a1} and the other
    bits (intra-subnet part) from \texttt{a2} and merge them to get a new
    address. This is useful for anonymizing at subnet level while preserving
    serial scans.
  \item \verb|is_tcp_port(p: port): bool|\\
    Checks whether \texttt{p} is a TCP port.
  \item \verb|is_udp_port(p: port): bool|\\
    Checks whether \texttt{p} is a UDP port.
  \item \verb|is_icmp_port(p: port): bool|\\
    Checks whether \texttt{p} is an ICMP port.
  \item \verb|active_connection(id: conn_id): bool|\\
    Checks whether the connection identified by \texttt{id} is (still) active.
  \item \verb|connection_exists(id: conn_id): bool|\\
    Same as \verb|active_connection|. \todo{Which one should we remove?}
  \item \verb|connection_record(id: conn_id): connection|\\
    Returns the \texttt{connection} record for \texttt{id}.
    Note that you \emph{must} first make sure that the connection is active
    (e.g., by calling \verb|active_connection|).
  \item \verb|lookup_connection(id: conn_id): connection|\\
    Same as \verb|lookup_connection|. \todo{Which one should we remove?}
  \item \verb|get_conn_transport_proto(id: conn_id): transport_proto|\\
    Returns the transport protocol of the connection identified by \texttt{id}.
    As with \verb|connection_record|, \texttt{id} must point to an active
    connection.
  \item \verb|get_port_transport_proto(p: port): transport_proto|\\
    Returns the transport protocol of \texttt{p}.
  \item \verb|set_inactivity_timeout(id: conn_id, t: interval): interval|\\
    Sets an individual inactivity timeout for the connection identified by
    \texttt{id} (overrides the global inactivity timeout).
    Returns the previous timeout interval.
    % TODO: are the next two functions worth keeping in the cheat sheet?
  \item \verb|get_login_state(id: conn_id): count|\\
    Returns the login state of the connection identified by \texttt{id}.
    Returns false if \texttt{id} is not an active connection or does not tagged
    as login analyzer. Otherwise the function returns the login state as
    a \texttt{count}.
  \item \verb|set_login_state(id: conn_id, new_state: count): bool|\\
    Sets the login state of the connection identified by \verb|id| to
    \verb|new_state|. Returns false if \texttt{id} is not an active connection
    or does not tagged as login analyzer, and true otherwise.
  \item \verb|get_resp_seq(id: conn_id): count|\\
    Returns the responder TCP sequence number of the connection identified by
    \texttt{id}. If the connection is not active or not TCP, it returns 0.
  \item \verb|unescape_URI(URI: string): string|\\
    Unescapes all characters in \texttt{URI}, i.e., decodes every \verb|%xx|
    group.
% TODO: wait for answer on bro-dev about these functions.
%  \item \verb|preserve_prefix(a: addr, width: count)|\\
%  \item \verb|preserve_subnet(sn: subnet)|\\
%  \item \verb|anonymize_addr(a: addr, cl: IPAddrAnonymizationClass): addr|\\
\end{itemize}

\subsubsection*{Files and Directories}

\begin{itemize}
  \item \verb|open(f: string): file|\\
    Opens the file identified by \texttt{f} for writing. Returns a handle
    for subsequent file operations.
  \item \verb|open_for_append(f: string): file|\\
    Same as \texttt{open}, except that \texttt{f} is not overwritten and
    content is appended at the end of the file.
  \item \verb|close(f: file): bool|\\
    Closes the file handle \texttt{f} and flushes buffered content. Returns
    true on success.
  \item \verb|active_file(f: file): bool|\\
    Checks whether \texttt{f} is open.
  \item \verb|write_file(f: file, data: string): bool|\\
    Writes \texttt{data} to \texttt{f}. Returns true on success.
  \item \verb|get_file_name(f: file): string|\\
    Returns the filename associated with \texttt{f}.
  \item \verb|set_buf(f: file, buffered: bool)|\\
    Alters the buffering behavior of \texttt{f}. When \texttt{buffered} is
    true, the file is fully buffered, i.e., bytes are saved in a buffered until
    the block size has been reached. When \texttt{buffered} is false, the file
    is line buffered, i.e., bytes are saved up until a newline occurs.
  \item \verb|flush_all(): bool|\\
    Flushes all open files to disk.
    Returns true when the operations(s) succeeded.
  \item \verb|mkdir(f: string): bool|\\
    Creates a new directory identified by \texttt{f}. Returns true if the
    operation succeeded and \texttt{f} does not exist already.
\end{itemize}

\end{multicols*}

\end{document}
