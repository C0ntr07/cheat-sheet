\documentclass[10pt,landscape]{article}

\usepackage{alltt}
\usepackage{enumitem}
\usepackage[T1]{fontenc}
\usepackage[landscape,margin=13mm,footskip=1pt,includefoot]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{setspace}
%\usepackage[compact]{titlesec}
\usepackage{upquote}
\usepackage{xspace}

\graphicspath{{figs/}}

\pagestyle{empty}
\parindent=0pt

\setitemize{itemsep=1pt,topsep=0pt,parsep=1pt,leftmargin=10pt}

\hypersetup{
    colorlinks=true,        % false: boxed links; true: colored links
    linkcolor=red,          % color of internal links
    citecolor=cyan,         % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=blue           % color of external links
}

\def\todo#1{\textit{\textcolor{red}{TODO: #1}}}
\newcommand{\minisec}[1]{\textsc{#1}\\}

\begin{document}

\begin{multicols*}{3}

{\Huge\scshape Bro Cheat Sheet}

\hfill\includegraphics[width=.4\linewidth]{bro-logo-small}
\vspace{-38pt}

{\scriptsize
\setstretch{1.5}
\begin{tabular}{l l}
Version: & \today\\
Website: & \url{http://www.bro-ids.org}\\
Email: & \texttt{\href{mailto:info@bro-ids.org}{info@bro-ids.org}}\\
Download: & \url{https://github.com/broids/cheat-sheet}
\end{tabular}
}

\section*{Startup}

\texttt{bro \textit{[options] [file \dots]}}\\
\texttt{\textit{file}} \dotfill Bro policy script or \texttt{stdin}\\
\texttt{-e \textit{code}} \dotfill Augment policies by given code\\
\texttt{-h} \dotfill Display command line options\\
\texttt{-i \textit{iface}} \dotfill Read from given interface\\
\texttt{-p \textit{pfx}} \dotfill Add given prefix to policy resolution\\
\texttt{-r \textit{file}} \dotfill Read from given PCAP file\\
\texttt{-w \textit{file}} \dotfill Write to given file in PCAP format\\
\texttt{-x \textit{file}} \dotfill Print contents of state file\\
\texttt{-C} \dotfill Ignore invalid checksum

\section*{Language}

Lowercase letters represent instance variables and uppercase letters represent
types. In general, \texttt{x} is an instance of type \texttt{T} and \texttt{y}
an instance of type \texttt{U}. Argument names and record fields begin begin
with \texttt{a}, \texttt{b},~\ldots, and \texttt{z} represents a default
instance variable which takes on the type of the right-hand side expression.
For notational convenience, \texttt{x} can often be replaced with an expression
of type \texttt{T}.
%Parenthesis after a type, e.g., \texttt{T()}, denote constructor invocation.

\subsection*{Variables}

Constant qualifier \dotfill \texttt{const}\\
Constant redefinition \dotfill \texttt{redef x \textit{op} \textit{expr}}\\
Scope qualifier \dotfill \texttt{local}, \texttt{global}\\
Declaration \dotfill \texttt{\textit{scope} x:~T}\\
Declaration \& Definition \dotfill \texttt{\textit{scope} z = \textit{expr}}

\subsection*{Declarations}

Type \dotfill \texttt{type~\textit{name}:~T}\\
Function \dotfill \verb|function f(a: T, ...): R|\\
Event \dotfill \verb|event e(a: T, ...)|

\subsection*{Modules}

Script import \dotfill \texttt{@load \textit{path}}\\
Set current namespace to \texttt{ns} \dotfill \texttt{module \textit{ns}}\\
Export global symbols \dotfill \verb|export { ... }|\\
Access \texttt{module} or \texttt{enum} namespace \dotfill \verb|T::a|

\subsection*{Statements}

Basic statement \dotfill
  \texttt{\textit{stmt};} or \texttt{\textit{expr};}\\
Code block \dotfill \texttt{\{ \textit{stmt}; ... \}}\\
Assignment \dotfill \texttt{z = \textit{expr}}\\
Function assignment \dotfill \texttt{z~=~function(...):~R~\{..\}}\\
Event queuing \dotfill \verb|event e(...)|\\
Event scheduling \dotfill \verb|schedule 10 secs { e(...) }|\\
Print expression to \texttt{stdout} \dotfill \texttt{print \textit{expr}}\\

\vspace{-10pt}
%\minisec{Control Flow}
\begin{multicols*}{3}
\textsc{Branching}
\begin{alltt}
if (\textit{expr})
    \{ \ldots \}
else if (\textit{expr})
    \{ \ldots \}
else
    \{ \ldots \}
\end{alltt}

\textsc{Iteration}
\begin{alltt}
for (i in x)
    \{ \ldots \}
\end{alltt}

\textsc{Asynchronous}
\begin{alltt}
when (\textit{expr}) \{ \ldots \}
when (local x = \textit{expr}) \{ \ldots \}
\end{alltt}
\vspace{-10pt}

\begin{alltt}
\textsc{Control}\vspace{5pt}
break
continue
next
return
\end{alltt}
\end{multicols*}

\subsection*{Expressions}

\minisec{Operators}
\verb|!| \dotfill Negation\\
\verb|$|, \verb|?$| \dotfill Dereference, record field existence\\
\verb|+|, \verb|-|, \verb|*|, \verb|/|, \verb|%| \dotfill Arithmetic\\
\verb|++|, \verb|--| \dotfill Post-increment, post-decrement\\
\verb|+=|, \verb|-=|, \verb|*=|, \verb|/=| \dotfill Arithmetic and assignment\\
\verb|==|, \verb|!=| \dotfill Equality, inequality\\
\verb|<|, \verb|<=|, \verb|>=|, \verb|>|
  \dotfill Less/greater than (or equal)\\
\verb|&&|, \verb#||# \dotfill Conjunction, disjunction\\
\verb|in|, \verb|!in| \dotfill Membership or pattern matching\\
\verb|[x]| \dotfill Index strings and containers\\
\verb#|x|# \dotfill Cardinality/size for strings and containers\\
\verb|f(...)| \dotfill Function call\\
\texttt{\textit{expr}$\;$?$\;$\textit{expr}$\;$:$\;$\textit{expr}}
  \dotfill Ternary if-then-else

\subsection*{Types}

\minisec{Basic}
\verb|addr| \dotfill IP address (\verb|127.0.0.1|)\\
\verb|bool| \dotfill Boolean flag (\verb|T|, \verb|F|)\\
\verb|count| \dotfill 64-bit unsigned integer (\verb|42|)\\
\verb|double| \dotfill Double-precision floating point (\verb|99.9|)\\
\verb|int| \dotfill 64-bit signed integer (\verb|-7|)\\
\verb|interval| \dotfill Time interval
  (\verb|8 sec|/\verb|min|/\verb|hr|/\verb|day[s]|)\\
\verb|pattern| \dotfill Regular expression (\verb|/^br[oO])$/|)\\
\verb|port| \dotfill Transport-layer port
  (\verb|22/tcp|, \verb|53/udp|)\\
\verb|string| \dotfill String of bytes (\verb|"foo"|)\\
\verb|subnet| \dotfill CIDR subnet mask (\verb|10.0.0.0/8|)\\
\verb|time| \dotfill Absolute epoch time (\verb|1320977325|)\\

\minisec{Enumerables}
Declaration \dotfill \verb|enum { FOO, BAR }|\\
Assignment \dotfill \texttt{\textit{scope}} \verb|x = FOO|\\

\minisec{Records}
Declaration \dotfill \verb|record { a: T, b: U, ... }|\\
Constructor \dotfill \verb|record($a=x, $b=y, ...)|\\
Assignment \dotfill \texttt{\textit{scope}} \verb|r = [$a=x, $b=y, ...]|\\
Access \dotfill \verb|z = r$a|\\
Field assignment \dotfill \verb|r$b = y|\\
Deletion \dotfill \verb|delete r$a|\\

\minisec{Sets}
Declaration \dotfill \verb|set[T]|\\
Constructor \dotfill \verb|set(x, ...)|\\
Assignment \dotfill \texttt{\textit{scope}} \verb|s = { x, ... }|\\
Access \dotfill \verb|z = s[x]|\\
Insertion \dotfill \verb|add s[x]|\\
Deletion \dotfill \verb|delete s[x]|\\

\minisec{Tables}
Declaration \dotfill \verb|table[T] of U|\\
Constructor \dotfill \verb|table([x] = y, ...)|\\
Assignment \dotfill \texttt{\textit{scope}} \verb|t = { [x] = y, ... }|\\
Access \dotfill \verb|z = t[x]|\\
Insertion \dotfill \verb|t[x] = y|\\
Deletion \dotfill \verb|delete t[x]|\\

\minisec{Vectors}
Declaration \dotfill \verb|vector of T|\\
Constructor \dotfill \verb|vector(x, ...)|\\
Assignment \dotfill \texttt{\textit{scope}} \verb|v = { x, ... }|\\
Access \dotfill \verb|z = v[0]|\\
Insertion \dotfill \verb|v[42] = x|
% FIXME: not yet supported in Bro, see #679.
%Deletion \dotfill \verb|delete v[3]|
\end{multicols*}

\begin{multicols*}{2}
\subsection*{Attributes}
Attributes occur at the end of type/event declarations and change their
behavior. The syntax is \verb|&key| or \verb|&key=val|, e.g.,
\verb|type T: set[count] &read_expire=5min| or
\verb|event foo() &priority=-3|.\\

\verb|&optional| \dotfill Allow record field to be missing\\
\verb|&default=x| \dotfill Use default value \texttt{x} for record fields and
  container elements\\
\verb|&redef| \dotfill Allow for redefinition of initial object value\\
% Users should use the logging framework instead.
%\verb|&rotate_interval=x| \dotfill Rotate file after time \verb|x|\\
%\verb|&rotate_size=x| \dotfill Rotate file after reaching size limit \verb|x|\\
%
% These do not seem to be worthwhile including
%\verb|&add_func=f| \dotfill Call \verb|f| after adding element to container\\
%\verb|&delete_func=f| \dotfill Call \verb|f| before deleting element from
%container \\
\verb|&expire_func=f| \dotfill Call \verb|f| right before container element
  expires\\
\verb|&read_expire=x| \dotfill Remove element after not reading it for time
  \verb|x|\\
\verb|&write_expire=x| \dotfill Remove element after not writing it for time
  \verb|x|\\
\verb|&create_expire=x| \dotfill Remove element after time \verb|x| from
  insertion\\
\verb|&persistent| \dotfill Write state to disk (per default on shutdown)\\
\verb|&synchronized| \dotfill Synchronize variable across nodes\\
% TODO: these are probably less relevant for users.
%\verb|&postprocessor| \dotfill \\
%\verb|&encrypt| \dotfill \\
%\verb|&match| \dotfill \\
\verb|&raw_output| \dotfill Do not escape non-ASCII characters when writing to
  a file\\
\verb|&mergeable| \dotfill Prefer set union to assignment for synchronized
  state\\
\verb|&priority=x| \dotfill Execution priority of event handler, high to low, $\mathtt{x} \in [-10,10]$\\
\verb|&group="x"| \dotfill Events in the same group can be jointly
  activated/deactivated\\
\verb|&log| \dotfill Write record field to log \\

\subsection*{Built-In Functions (BIFs)}
\linespread{0.9}

\subsubsection*{Core}

\begin{itemize}
    %
    % Introspection
    %
  \item \verb|current_time(): time|\\
    Returns the current wall-clock time.
  \item \verb|network_time(): time|\\
    Returns the timestamp of the last packet processed.
  \item \verb|reading_live_traffic(): bool|\\
    Checks whether Bro reads traffic from a network interface (as opposed to
    from a network trace).
  \item \verb|reading_traces(): bool|\\
    Checks whether Bro reads traffic from a trace file (as opposed to
    from a network interface).
  \item \verb|getenv(var: string): string|\\
    Returns the system environment variable identified by \texttt{var}.
  \item \verb|setenv(var: string, val: string): bool|\\
    Sets the system environment variable \texttt{var} to \texttt{val}.
  \item \verb|exit(): int|
    Shuts down the Bro process immediately and returns 0.
  \item \verb|terminate(): bool|
    Gracefully shut down Bro by terminating outstanding processing. Returns
    true after successful termination and false when Bro is still in the
    process of shutting down.
  \item \verb|system(s: string): int|\\
    Invokes a command via the \texttt{system} function.
    Returns true if the return value of \texttt{system} was non-zero.
  \item \verb|system_env(s: string, env: any): int|\\
    Same as \verb|system|, but prepare the environment before invoking the
    command \texttt{s} with the set/table \texttt{env}.
  \item \verb|skip_further_processing(id: conn_id): bool|\\
    Stops processing packets belonging to the connection identified by
    \texttt{id}.
    Returns false if \texttt{id} does not point to an active connection and
    true otherwise.
    Note that this does not in itself imply that packets from this connection
    will not be recorded, which is controlled separately by
    \verb|set_record_packets|.
    \todo{Someone please verify this.}
  \item \verb|set_record_packets(id: conn_id, do_record: bool): bool|\\
    Controls whether packet contents belonging to the connection identified by
    \texttt{id} should be recorded.
    Note that this is independent of whether Bro processes the packets of this
    connection, which is controlled separately by
    \verb|skip_further_processing|.
    \todo{Someone please verify this.}
  \item \verb|set_contents_file(id: conn_id, direction: count, f: file): bool|\\
    Associates the file handle \texttt{f} with the connection identified by
    \texttt{id} for writing TCP byte stream contents. The argument
    \texttt{direction} controls what sides of the connection contents are
    recorded; it can take on four values:
    \verb|CONTENTS_NONE| to turn off recording of contents,
    \verb|CONTENTS_ORIG| to record originator contents,
    \verb|CONTENTS_RESP| to record responder contents,
    and \verb|CONTENTS_BOTH| to record both originator and responder contents.
    Returns false if \texttt{id} does not point to an active connection and
    true otherwise.
  \item \verb|get_contents_file(id: conn_id, direction: count): file|\\
    Returns the file handle associated with the connection identified by
    \texttt{id} and \texttt{direction}. If the connection exists but no
    contents file for \texttt{direction}, the function returns a handle to new
    file. If not active connection for \texttt{id} exists, it returns an error.
    %
    % Generic functions
    %
  \item \verb|same_object(o1: any, o2: any): bool|\\
    Checks whether \texttt{o1} and \texttt{o2} reference the same internal
    object.
  \item \verb|length(v: any): count|\\
    Returns the number of elements in the container \texttt{v}.
  \item \verb|clear_table(v: any): any|\\
    Removes all elements from the set or table \texttt{v}.
\end{itemize}

\subsubsection*{Files and Directories}

\begin{itemize}
  \item \verb|open(f: string): file|\\
    Opens the file identified by \texttt{f} for writing. Returns a handle
    for subsequent file operations.
  \item \verb|open(f: string): file|\\
    Same as \texttt{open}, except that \texttt{f} is not overwritten and
    content is appended at the end of the file.
  \item \verb|close(f: file): bool|\\
    Closes the file handle \texttt{f} and flushes buffered content. Returns
    true on success.
  \item \verb|active_file(f: file): bool|\\
    Checks whether \texttt{f} is open.
  \item \verb|write_file(f: file, data: string): bool|\\
    Writes \texttt{data} to \texttt{f}. Returns true on success.
  \item \verb|get_file_name(f: file): string|\\
    Returns the filename of the file identified by the handle \texttt{f}.
  \item \verb|set_buf(f: file, buffered: bool): any|\\
    Alters the buffering behavior of \texttt{f}. When \texttt{buffered} is
    true, the file is fully buffered, i.e., bytes are saved in a buffered until
    the block size has been reached. When \texttt{buffered} is false, the file
    is line buffered, i.e., bytes are saved up until a newline occurs. The
    return value is \texttt{void} and can be discarded.
    \todo{Why is it not void then?}
  \item \verb|flush_all(): bool|\\
    Flushes all open files to disk.
    Returns true when the operations(s) succeeded.
  \item \verb|mkdir(f: string): bool|\\
    Creates a new directory identified by \texttt{f}. Returns true if the
    operation succeeded and \texttt{f} does not exist already.
\end{itemize}

\subsubsection*{Conversion}

\begin{itemize}
  \item \verb|cat(...): string|\\
    Concatenates all given arguments into a single string.
  \item \verb|cat_sep(sep: string, def: string, ...): string|\\
    Similar to cat, but places \texttt{sep} between each given argument.
    \todo{what does \texttt{def} do?}
  \item \verb|fmt(...): string|\\
    Produces a formatted string. The first argument is the \emph{format string}
    and specifies how subsequent arguments are converted for output. It is
    composed of zero or more directives: ordinary characters (not \verb|%|),
    which are copied unchanged to the output, and conversion specifications,
    each of which fetches zero or more subsequent arguments. Conversion
    specifications begin with \verb|%| and the arguments must properly
    correspond to the specifier.

    After the \verb|%|, the following characters may appear in sequence:
    \begin{tabular}{l l}
      \verb|%| & Literal \verb|%|\\
      \verb|-| & Left-align field\\
      \verb|[0-9]+| & The field width (< 128)\\
      \verb|.| & Precision of floating point specifiers \verb|[efg]| (< 128)\\
      \verb|A| & \verb|ALTERNATIVE_STYLE| \todo{means what?}\\
      \verb|[DTdxsefg]| &
        \begin{minipage}[t]{\linewidth}
          Format specifier\\
          \begin{tabular}{l p{.7\linewidth}}
            \texttt{[DT]} & ISO timestamp with microsecond precision\\
            \texttt{d} & Signed/Unsigned integer (using C-style
              \verb|%lld|/\verb|%llu| for \texttt{int}/\texttt{count})\\
            \texttt{x} & Unsigned hexadecimal (using C-style \verb|%llx|);
              addresses/ports are converted to host-byte order\\
            \texttt{s} & Escaped string\\
            \texttt{[efg]} & Double\\
          \end{tabular}
        \end{minipage}\\
    \end{tabular}
  \item \verb|type_name(t: any): string|\\
    Returns the type name of \texttt{t}.
  % TODO: maybe to low-level for the cheat sheet?
  \item \verb|record_type_to_vector(rt: string): vector of string|\\
    Converts the record type name \texttt{rt} into a vector of strings, where
    each element is the name of a record field. Nested records are flattened.
  \item \verb|to_int(s: string): int|\\
    Converts a \texttt{string} into a (signed) integer.
  \item \verb|int_to_count(n: int): count|\\
    Converts a positive integer into a \texttt{count} or returns 0 if
    \texttt{n < 0}.
  \item \verb|double_to_count(d: double): count|\\
    Converts a positive \texttt{double} into a \texttt{count} or returns 0 if
    \texttt{d < 0.0}.
  \item \verb|to_count(s: string): count|\\
    Converts a \texttt{string} into a \texttt{count}.
  \item \verb|interval_to_double(i: interval): double|\\
    Converts an \texttt{interval} time span into a \texttt{double}.
  \item \verb|double_to_interval(d: double): interval|\\
    Converts a \texttt{double} into an \texttt{interval}.
  \item \verb|time_to_double(t: time): double|\\
    Converts a \texttt{time} value into a \texttt{double}.
  \item \verb|double_to_time(d: double): time|\\
    Converts a \texttt{double} into a \texttt{time} value.
  \item \verb|double_to_time(d: double): time|\\
    Converts a \texttt{double} into a \texttt{time} value.
  \item \verb|port_to_count(p: port): count|\\
    Returns the port number of \texttt{p} as \texttt{count}.
  \item \verb|count_to_port(c: count, t: transport_proto): port|\\
    Create a \texttt{port} with number \texttt{c} and transport protocol
    \texttt{t}.
  \item \verb|to_port(c: count, t: transport_proto): port|\\
    Same as \verb|count_to_port|.
  \item \verb|addr_to_count(a: addr): count|\\
    Converts an IP address into a 32-bit unsigned integer.
  \item \verb|count_to_v4_addr(ip: count): addr|\\
    Converts an unsigned integer into an IP address.
  \item \verb|to_addr(ip: string): addr|\\
    Converts a \texttt{string} into an IP address.
  \item \verb|raw_bytes_to_v4_addr(b: string): addr|\\
    Converts a \texttt{string} of bytes into an IP address. It interprets the
    first 4 bytes of \texttt{b} as an IPv4 address in network order.
\end{itemize}

\subsubsection*{Network Type Processing}

\begin{itemize}
  \item \verb|mask_addr(a: addr, top_bits_to_keep: count): subnet|\\
    Creates a subnet mask from \texttt{a} by specifying the number of top bits
    to keep. For example, \verb|mask_addr(10.5.1.3, 8)| would return
    \verb|10.0.0.0/8|.
  \item \verb|remask_addr(a1: addr, a2: addr, top_bits_from_a1: count): count|\\
    Takes some top bits (e.g., subnet address) from \texttt{a1} and the other
    bits (intra-subnet part) from \texttt{a2} and merge them to get a new
    address. This is useful for anonymizing at subnet level while preserving
    serial scans.
  \item \verb|is_tcp_port(p: port): bool|\\
    Checks whether \texttt{p} is a TCP port.
  \item \verb|is_udp_port(p: port): bool|\\
    Checks whether \texttt{p} is a UDP port.
  \item \verb|is_icmp_port(p: port): bool|\\
    Checks whether \texttt{p} is an ICMP port.
  \item \verb|active_connection(id: conn_id): bool|\\
    Checks whether the connection identified by \texttt{id} is (still) active.
  \item \verb|connection_exists(id: conn_id): bool|\\
    Same as \verb|active_connection|. \todo{Which one should we remove?}
  \item \verb|connection_record(id: conn_id): connection|\\
    Returns the \texttt{connection} record for \texttt{id}.
    Note that you \emph{must} first make sure that the connection is active
    (e.g., by calling \verb|active_connection|).
  \item \verb|lookup_connection(id: conn_id): connection|\\
    Same as \verb|lookup_connection|. \todo{Which one should we remove?}
  \item \verb|get_conn_transport_proto(id: conn_id): transport_proto|\\
    Returns the transport protocol of the connection identified by \texttt{id}.
    As with \verb|connection_record|, \texttt{id} must point to an active
    connection.
  \item \verb|get_port_transport_proto(p: port): transport_proto|\\
    Returns the transport protocol of \texttt{p}.
\end{itemize}

\subsubsection*{Math}

\begin{itemize}
  \item \verb|floor(x: double): double|\\
    Chops off any decimal digits, i.e., computes $\lfloor\mathtt{x}\rfloor$.
  \item \verb|sqrt(x: double): double|\\
    Returns the square root of \texttt{x}, i.e., computes $\sqrt{\mathtt{x}}$.
  \item \verb|sqrt(x: double): double|\\
    Raises $e$ to the power of \texttt{x}, i.e., computes $e^\mathtt{x}$.
  \item \verb|ln(x: double): double|\\
    Returns the natural logarithm of \texttt{x},
    i.e., computes $\ln \mathtt{x}$.
  \item \verb|log10(x: double): double|\\
    Returns the common logarithm of \texttt{x},
    i.e., computes $\log_{10} \mathtt{x}$.
\end{itemize}

\subsubsection*{String Processing}

\begin{itemize}
  \item \verb|byte_len(s: string): count|\\
    Returns the number of characters (i.e., bytes) of \texttt{s}.
  \item \verb|sub_bytes(s: string, start: count, n: int): string|\\
    Get a substring of \texttt{s}, starting at position \texttt{start} and
    having length \texttt{n}.
  \item \verb|split(s: string, re: pattern): table[count] of string|\\
    Split \texttt{s} into an array using \texttt{re} to separate the elements.
    The returned table starts at index 1. Note that conceptually the return
    value is meant to be a vector and this might change in the future.
  \item \verb|split1(s: string, re: pattern): table[count] of string|\\
    Same as \texttt{split}, but \texttt{s} is only split once (if possible) at
    the earliest position and an array of two strings is returned. An array of
    one string is returned when \texttt{s} cannot be split.
  \item \verb|split_all(s: string, re: pattern): table[count] of string|\\
    Same as \texttt{split}, but also include the matching separators, e.g.,
    \verb|split_all("a-b--cd", /(\-)+/)| returns
    \verb|{"a", "-", "b", "--", "cd"}|. Odd-indexed elements do not match the
    pattern and even-indexed ones do.
  \item
\begin{verbatim}
split_n(s: string, re: pattern, incl_sep: bool,
        max_num_sep: count): table[count] of string
\end{verbatim}
    Similar to \verb|split1| and \verb|split_all|, but \verb|incl_sep|
    indicates whether to include matching separators and \verb|max_num_sep| the
    number of times to split \texttt{s}.
%  \item
%\begin{verbatim}
%function split_complete(s string, re: pattern,
%                        other: set[string], incl_sep: bool,
%                        max_num_sep: count): table[count] of string
%\end{verbatim}
%    Same as \verb|split_n|, except that the extra parameter \texttt{other} is
%    not used.
  \item \verb|sub(s: string, re: pattern, repl: string): string|\\
    Substitutes \texttt{repl} for the first occurrence of \texttt{re} in
    \texttt{s}.
  \item \verb|gsub(s: string, re: pattern, repl: string): string|\\
    Same as \texttt{sub} except that all occurrences of \texttt{re} are
    replaced.
  \item \verb|strcmp(s1: string, s2: string): int|
    Lexicographically compare \texttt{s1} and \texttt{s2}. Returns an integer
    greater than, equal to, or less than 0 according as \texttt{s1} is greater
    than, equal to, or less than \texttt{s2}.
  \item \verb|strstr(big: string, little: string): count|\\
    Locate the first occurrence of \texttt{little} in \texttt{big}.
    Returns 0 if \texttt{little} is not found in \texttt{big}.
  \item \verb|subst_string(s: string, from: string, to: string): string|\\
    Substitute each (non-overlapping) appearance of \texttt{from} in
    \texttt{s} to \texttt{to}, and return the resulting string.
  \item \verb|to_lower(s: string): string|\\
    Returns a copy of \texttt{s} with each letter converted to lower case.
  \item \verb|to_upper(s: string): string|\\
    Returns a copy of \texttt{s} with each letter converted to upper case.
  \item \verb|clean(s: string): string|\\
    Replace non-printable characters in \texttt{s} with escaped sequences,
    with the mappings
    \verb|0| $\rightarrow$ \verb|\0|,
    \verb|DEL| $\rightarrow$ \verb|^?|,
    values $\le 26$ $\rightarrow$ \verb|^[A-Z]|,
    and values not in $[32, 126]$~$\rightarrow$~\verb|%XX|.
  \item \verb|to_string_literal(s: string): string|\\
    Same as clean, but with different mappings:
    values not in $[32, 126]$~$\rightarrow$~\verb|%XX|,
    \verb|\|~$\rightarrow$~\verb|\\|,
    \verb|'|~$\rightarrow$~\verb|\'|,
    \verb|"|~$\rightarrow$~\verb|\"|.
  \item \verb|is_ascii(s: string): bool|\\
    Returns false if any byte value of \texttt{s} is greater than 127, and true
    otherwise.
  \item \verb|escape_string(s: string): string|\\
    Returns a printable version of \texttt{s}. Same as \texttt{clean} except
    that non-printable characters are removed.
  \item \verb|string_to_ascii_hex(s: string): string|\\
    Returns an ASCII hexadecimal representation of a string.
  \item \verb|str_split(s: string, idx: vector of count): vector of string|\\
    Splits \texttt{s} into substrings, taking all the indices in
    \texttt{idx} as cutting points; \texttt{idx} does not need to be sorted and
    out-of-bounds indices are ignored.
  \item \verb|strip(s: string): string|\\
    Strips whitespace at both ends of \texttt{s}.
  \item \verb|string_fill(len: int, source: string): string|\\
    Generates a string of size \texttt{len} and fills it with repetitions of
    \texttt{source}.
  \item \verb|str_shell_escape(source: string): string|\\
    Takes a string and escapes characters that would allow execution of
    commands at the shell level. Must be used before including strings in
    \texttt{system()} or similar calls.
  \item \verb|find_all(s: string, re: pattern) : set of string|\\
    Returns all occurrences of \texttt{re} in \texttt{s} (or an empty empty set
    if none).
  \item \verb|find_last(s: string, re: pattern) : string|\\
    Returns the last occurrence of \texttt{re} in \texttt{s}. If not found,
    returns an empty string.  Note that this function returns the match that
    starts at the largest index in the string, which is not necessarily the
    longest match.  For example, a pattern of \texttt{/.*/} will return the
    final character in the string.
  \item \verb|hexdump(data: string) : string|\\
    Returns a hex dump for \texttt{data}. The hex dump renders 16 bytes per
    line, with hex on the left and ASCII (where printable) on the right. Based
    on Netdude's hex editor code.
\end{itemize}

\end{multicols*}

\end{document}
